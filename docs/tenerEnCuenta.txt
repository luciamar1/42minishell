PARSER

- '' dejan el input tal cual esta
- "" hacen lo mismo, salvo por el output
- tomaremos los caracteres \ y ; como texto plano
- si hay varios $ seguidos, se interpretan en orden


EXECUTER

- si hay varios </<< se toma el ultimo solo, lo mismo con >/>>. Se prioriza el (>>/> o <</<) antes quel pipe (pero hay que abrir todos, por ejemplo si tenemos ls > a > b, a y b tienen que abrirse)


HERE_DOC

- "" y '' anywhere in delimiter avoids expansions
- delimiter is not expanded
- the only way in which the input is edited is expanding variables when there are no quotes
- when we are inside heredoc, signal handling funcitions have to change


FLOW OF INPUT TILL EXECUTED

input -> lexer -> parser -> expander -> executer

lexer: returns a list of tokens which can be words or operators. Is in charge of identifying unclosed quotes
parser: returns a list of t_commands. Is in charge of identifying invalid operator orders such as >>>
expander: same as parser but expanded
executer: executes commands in order assuming pipes between them (an overcomplicated pipex)


SIGNALS

Executing:			Ctrl + C and Ctrl + \ handled by the execve. Ctrl + D, if its not recieved by the process, should wait till process ends and exit
For heredoc: 		Ctrl + C cancels command, exits 1. Ctrl + \ does nothing. Ctrl + D exits from the heredoc its in, exits 0.
Interactive mode:	Ctrl + C newline, exits 1. Ctrl + \ does nothing. Ctrl + D exits.


OTHER

what to do with heredoc
probably unclosed ', "" and | behave the same way as heredoc
When executing multiple commnands, separated by pipes, a subshell for each command must be generated. This means that for example the command 'cd dir | echo a' wont cd us to dir, because it well get executed in a subshell(similarly to a script)  